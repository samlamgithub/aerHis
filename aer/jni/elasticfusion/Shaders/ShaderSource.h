/*
 * This file is part of ElasticFusion.
 *
 * Copyright (C) 2015 Imperial College London
 *
 * The use of the code within this file and all code within files that
 * make up the software that is ElasticFusion is permitted for
 * non-commercial purposes only.  The full terms and conditions that
 * apply to the code within this file are detailed within the LICENSE.txt
 * file and at <http://www.imperial.ac.uk/dyson-robotics-lab/downloads/elastic-fusion/elastic-fusion-license/>
 * unless explicitly stated.  By downloading this file you agree to
 * comply with these terms.
 *
 * If you wish to use any of this code for commercial purposes then
 * please email researchcontracts.engineering@imperial.ac.uk.
 *
 */

#ifndef SHADERS_SHADERSSOURCE_H_
#define SHADERS_SHADERSSOURCE_H_

#include <tuple>
#include <string>

static const char combo_splatfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"uniform vec4 cam; //cx, cy, fx, fy\n"
"uniform float maxDepth;\n"
"in vec4 position;\n"
"in vec4 normRad;\n"
"in vec4 colTime;\n"
"layout(location = 0) out vec4 image;\n"
"layout(location = 1) out vec4 vertex;\n"
"layout(location = 2) out vec4 normal;\n"
"layout(location = 3) out uint time;\n"
"float encodeColor(vec3 c) {\n"
"    int rgb = int(round(c.x * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n"
"    return float(rgb);}\n"
"vec3 decodeColor(float c) {\n"
"    vec3 col;\n"
"    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n"
"    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n"
"    col.z = float(int(c) & 0xFF) / 255.0f;\n"
"    return col;}\n"
"void main() {\n"
"    vec3 l = normalize(vec3((vec2(gl_FragCoord) - cam.xy) / cam.zw, 1.0f));\n"
"    vec3 corrected_pos = (dot(position.xyz, normRad.xyz) / dot(l, normRad.xyz)) * l; \n"
"    //check if the intersection is inside the surfel\n"
"    float sqrRad = pow(normRad.w, 2.0);\n"
"    vec3 diff = corrected_pos - position.xyz;\n"
"    if(dot(diff, diff) > sqrRad) {\n"
"        discard;\n"
"    }\n"
"    image = vec4(decodeColor(colTime.x), 1);\n"
"    float z = corrected_pos.z;\n"
"    vertex = vec4((gl_FragCoord.x - cam.x) * z * (1.f / cam.z), (gl_FragCoord.y - cam.y) * z * (1.f / cam.w), z, position.w);\n"
"    normal = normRad;\n"
"    time = uint(colTime.z);\n"
"    gl_FragDepth = (corrected_pos.z / (2.0 * maxDepth)) + 0.5f;\n"
"}\n";
static const std::tuple<std::string, std::string> combo_splatfrag_tuple = std::make_tuple("combo_splatfrag", combo_splatfrag_source);

static const char copy_unstablegeom_source[]=
"#version 310 es\n"
"#extension GL_EXT_geometry_shader : require\n"
"precision highp float;\n"
"precision highp int;\n"
"layout(points) in;\n"
"layout(points, max_vertices = 1) out;\n"
"in vec4 vPosition[];\n"
"in vec4 vColor[];\n"
"in vec4 vNormRad[];\n"
"flat in int test[];\n"
"out vec4 vPosition0;\n"
"out vec4 vColor0;\n"
"out vec4 vNormRad0;\n"
"void main() {\n"
"    if(test[0] > 0) {\n"
"        vPosition0 = vPosition[0];\n"
"        vColor0 = vColor[0];\n"
"        vNormRad0 = vNormRad[0];\n"
"        EmitVertex();\n"
"        EndPrimitive(); \n"
"    }\n"
"}\n"
static const std::tuple<std::string, std::string> copy_unstablegeom_tuple = std::make_tuple("copy_unstablegeom", copy_unstablegeom_source);

static const char copy_unstablevert_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"layout (location = 0) in vec4 vPos;\n"
"layout (location = 1) in vec4 vCol;\n"
"layout (location = 2) in vec4 vNormR;\n"
"out vec4 vPosition;\n"
"out vec4 vColor;\n"
"out vec4 vNormRad;\n"
"flat out int test;\n"
"uniform int time;\n"
"uniform float scale;\n"
"uniform mat4 t_inv;\n"
"uniform vec4 cam; //cx, cy, fx, fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform float confThreshold;\n"
"uniform usampler2D indexSampler;\n"
"uniform sampler2D vertConfSampler;\n"
"uniform sampler2D colorTimeSampler;\n"
"uniform sampler2D normRadSampler;\n"
"uniform sampler2D nodeSampler;\n"
"uniform sampler2D depthSampler;\n"
"uniform float nodes;\n"
"uniform float nodeCols;\n"
"uniform float maxDepth;\n"
"uniform int timeDelta;\n"
"uniform int isFern;\n"
"void main() {\n"
"    vPosition = vPos;\n"
"    vColor = vCol;\n"
"    vNormRad = vNormR;\n"
"    test = 1;\n"
"    vec3 localPos = (t_inv * vec4(vPosition.xyz, 1.0f)).xyz;\n"
"    float x = ((cam.z * localPos.x) / localPos.z) + cam.x;\n"
"    float y = ((cam.w * localPos.y) / localPos.z) + cam.y;\n"
"    vec3 localNorm = normalize(mat3(t_inv) * vNormRad.xyz);\n"
"    float indexXStep = (1.0f / (cols * scale)) * 0.5f;\n"
"    float indexYStep = (1.0f / (rows * scale)) * 0.5f;\n"
"    float windowMultiplier = 2.0;\n"
"    int count = 0;\n"
"    int zCount = 0;\n"
"    if(//abs(localNorm.z) > 0.85f &&\n"
"       float(time) - vColor.w < float(timeDelta) && localPos.z > 0.0 && x > 0.0 && y > 0.0 && x < cols && y < rows) {\n"
"        for(float i = x / cols - (scale * indexXStep * windowMultiplier); i < x / cols + (scale * indexXStep * windowMultiplier); i += indexXStep) {\n"
"            for(float j = y / rows - (scale * indexYStep * windowMultiplier); j < y / rows + (scale * indexYStep * windowMultiplier); j += indexYStep) {\n"
"               uint current = uint(textureLod(indexSampler, vec2(i, j), 0.0));\n"
"               if(current > 0U) {\n"
"                   vec4 vertConf = textureLod(vertConfSampler, vec2(i, j), 0.0);\n"
"                   vec4 colorTime = textureLod(colorTimeSampler, vec2(i, j), 0.0);\n"
"                   if(colorTime.z < vColor.z && \n"
"                      vertConf.w > confThreshold && \n"
"                      vertConf.z > localPos.z && \n"
"                      vertConf.z - localPos.z < 0.01 &&\n"
"                      sqrt(dot(vertConf.xy - localPos.xy, vertConf.xy - localPos.xy)) < vNormRad.w * 1.4) {\n"
"                       count++; }\n"
"                   if(colorTime.w == float(time) &&\n"
"                      vertConf.w > confThreshold && \n"
"                      vertConf.z > localPos.z && \n"
"                      vertConf.z - localPos.z > 0.01 &&\n"
"                      abs(localNorm.z) > 0.85f) {\n"
"                       zCount++; }\n"
"               }\n"
"            }\n"
"        }\n"
"    }\n"
"    if(count > 8 || zCount > 4) {\n"
"        test = 0;\n"
"    }\n"
"    //New unstable point\n"
"    if(vColor.w == -2.0) {\n"
"        vColor.w = float(time);\n"
"    }\n"
"    //Degenerate case or too unstable\n"
"    if((vColor.w == -1.0 || ((float(time) - vColor.w) > 20.0 && vPosition.w < confThreshold))) {\n"
"        test = 0;\n"
"    }\n"
"    if(vColor.w > 0.0 && float(time) - vColor.w > float(timeDelta)) {\n"
"        test = 1;\n"
"    }\n"
"    //This is probably really slow\n"
"    //We don't deform vColor.z == time because they were fused with the updated pose already!\n"
"    if(test == 1 && nodes > 0.0 && vColor.z != float(time)) {\n"
"        const int k = 4;\n"
"        const int lookBack = 20;\n"
"        int nearNodes[lookBack];\n"
"        float nearDists[lookBack];\n"
"        for(int i = 0; i < lookBack; i++) {\n"
"            nearNodes[i] = -1;\n"
"            nearDists[i] = 16777216.0f;\n"
"        }\n"
"        int poseTime = int(vColor.z);\n"
"        int foundIndex = 0;\n"
"        int imin = 0;\n"
"        int imax = int(nodes) - 1;\n"
"        int imid = (imin + imax) / 2;\n"
"        while(imax >= imin) {\n"
"            imid = (imin + imax) / 2;\n"
"            int nodeTime = int(textureLod(nodeSampler, vec2(((float(imid) * 16.0 + 15.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            if(nodeTime < poseTime) {\n"
"                imin = imid + 1;\n"
"            } else if(nodeTime > poseTime) {\n"
"                imax = imid - 1;\n"
"            } else {\n"
"                break;\n"
"            }\n"
"        }\n"
"        imin = min(imin, int(nodes) - 1);\n"
"        int nodeMin = int(textureLod(nodeSampler, vec2(((float(imin) * 16.0 + 15.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"        int nodeMid = int(textureLod(nodeSampler, vec2(((float(imid) * 16.0 + 15.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"        int nodeMax = int(textureLod(nodeSampler, vec2(((float(imax) * 16.0 + 15.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"        if(abs(nodeMin - poseTime) <= abs(nodeMid - poseTime) &&\n"
"           abs(nodeMin - poseTime) <= abs(nodeMax - poseTime)) {\n"
"            foundIndex = imin;\n"
"        } else if(abs(nodeMid - poseTime) <= abs(nodeMin - poseTime) &&\n"
"                abs(nodeMid - poseTime) <= abs(nodeMax - poseTime)) {\n"
"            foundIndex = imid;\n"
"        } else {\n"
"            foundIndex = imax;\n"
"        }\n"
"        if(foundIndex == int(nodes)) {\n"
"            foundIndex = int(nodes) - 1;\n"
"        }\n"
"        int nearNodeIndex = 0;\n"
"        int distanceBack = 0;\n"
"        for(int j = foundIndex; j >= 0; j--) {\n"
"            vec3 position = vec3(textureLod(nodeSampler, vec2(((float(j) * 16.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(j) * 16.0 + 1.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(j) * 16.0 + 2.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            nearNodes[nearNodeIndex] = j;\n"
"            nearDists[nearNodeIndex] = sqrt(dot(vPosition.xyz - position, vPosition.xyz - position));\n"
"            nearNodeIndex++;\n"
"            if(++distanceBack == lookBack / 2) {\n"
"                break;\n"
"            }\n"
"        }\n"
"        for(int j = foundIndex + 1; j < int(nodes); j++) {\n"
"            vec3 position = vec3(textureLod(nodeSampler, vec2(((float(j) * 16.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(j) * 16.0 + 1.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(j) * 16.0 + 2.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            nearNodes[nearNodeIndex] = j;\n"
"            nearDists[nearNodeIndex] = sqrt(dot(vPosition.xyz - position, vPosition.xyz - position));\n"
"            nearNodeIndex++;\n"
"            if(++distanceBack == lookBack) {\n"
"                break;\n"
"            }\n"
"        }\n"
"        for(int i = 0; i < lookBack - 1; ++i) {\n"
"            for(int j = i + 1; j < lookBack; ++j) {\n"
"                if(nearDists[j] < nearDists[i]) {\n"
"                    float t = nearDists[i];\n"
"                    nearDists[i] = nearDists[j];\n"
"                    nearDists[j] = t;\n"
"                    int t2 = nearNodes[i];\n"
"                    nearNodes[i] = nearNodes[j];\n"
"                    nearNodes[j] = t2;\n"
"                }\n"
"            }\n"
"        }\n"
"        float dMax = nearDists[k];\n"
"        float nodeWeights[k];\n"
"        float weightSum = 0.0;\n"
"        for(int j = 0; j < k; j++) {\n"
"            vec3 position = vec3(textureLod(nodeSampler, vec2(((float(nearNodes[j]) * 16.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(nearNodes[j]) * 16.0 + 1.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(nearNodes[j]) * 16.0 + 2.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            nodeWeights[j] = pow(1.0f - (sqrt(dot(vPosition.xyz - position, vPosition.xyz - position)) / dMax), 2.0);\n"
"            weightSum += nodeWeights[j];\n"
"        }\n"
"        for(int j = 0; j < k; j++) {\n"
"            nodeWeights[j] /= weightSum;\n"
"        }\n"
"        vec3 newPos = vec3(0, 0, 0);\n"
"        vec3 newNorm = vec3(0, 0, 0);\n"
"        for(int i = 0; i < k; i++) {\n"
"            vec3 position = vec3(textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 1.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                 textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 2.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            vec3 column0 = vec3(textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 3.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 4.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x,\n"
"                                textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 5.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            vec3 column1 = vec3(textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 6.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 7.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x,\n"
"                                textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 8.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            vec3 column2 = vec3(textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 9.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 10.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x,\n"
"                                textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 11.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            mat3 rotation = mat3(column0, column1, column2);\n"
"            vec3 translation = vec3(textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 12.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x, \n"
"                                    textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 13.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x,\n"
"                                    textureLod(nodeSampler, vec2(((float(nearNodes[i]) * 16.0 + 14.0) / nodeCols) + (1.0 / (nodeCols * 2.0)), 0.5), 0.0).x);\n"
"            newPos += nodeWeights[i] * (rotation * (vPosition.xyz - position) + position + translation);\n"
"            newNorm += nodeWeights[i] * (transpose(inverse(rotation)) * vNormRad.xyz);\n"
"        }\n"
"        vPosition.xyz = newPos;\n"
"        vNormRad.xyz = normalize(newNorm);\n"
"        if(vPosition.w > confThreshold && isFern == 0) {\n"
"            localPos = (t_inv * vec4(vPosition.xyz, 1.0f)).xyz;\n"
"            x = ((cam.z * localPos.x) / localPos.z) + cam.x;\n"
"            y = ((cam.w * localPos.y) / localPos.z) + cam.y;\n"
"            if(localPos.z > 0.0 && localPos.z < maxDepth && x > 0.0 && y > 0.0 && x < cols && y < rows) {\n"
"                float currentDepth = float(textureLod(depthSampler, vec2(x / cols, y / rows), 0.0));\n"
"                if(currentDepth > 0.0f && localPos.z < currentDepth + 0.1f) {\n"
"                    vColor.w = float(time);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> copy_unstablevert_tuple = std::make_tuple("copy_unstablevert", copy_unstablevert_source);

static const char datafrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 vPosition0;\n"
"in vec4 vColor0;\n"
"in vec4 vNormRad0;\n"
"flat in int updateId0;\n"
"layout(location = 0) out vec4 vPosition1;\n"
"layout(location = 1) out vec4 vColor1;\n"
"layout(location = 2) out vec4 vNormRad1;\n"
"void main() {\n"
"    //If we have a point to update in the existing model, store that\n"
"    if(updateId0 == 1) {\n"
"        vPosition1 = vPosition0;\n"
"        vColor1 = vColor0;\n"
"        vNormRad1 = vNormRad0;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> datafrag_tuple = std::make_tuple("datafrag", datafrag_source);

static const char datageom_source[]=
"#version 310 es\n"
"#extension GL_EXT_geometry_shader : require\n"
"precision highp float;\n"
"precision highp int;\n"
"layout(points) in;\n"
"layout(points, max_vertices = 1) out;\n"
"in vec4 vPosition[];\n"
"in vec4 vColor[];\n"
"in vec4 vNormRad[];\n"
"flat in int updateId[];\n"
"out vec4 vPosition0;\n"
"out vec4 vColor0;\n"
"out vec4 vNormRad0;\n"
"flat out int updateId0;\n"
"void main() {\n"
"    //Emit a vertex if either we have an update to store, or a new unstable vertex to store\n"
"    if(updateId[0] > 0)  {\n"
"        vPosition0 = vPosition[0];\n"
"        vColor0 = vColor[0];\n"
"        vNormRad0 = vNormRad[0];\n"
"        updateId0 = updateId[0];\n"
"        \n"
"        //This will be -10, -10 (offscreen) for new unstable vertices, so they don't show in the fragment shader\n"
"        gl_Position = gl_in[0].gl_Position;\n"
"        EmitVertex();\n"
"        EndPrimitive(); \n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> datageom_tuple = std::make_tuple("datageom", datageom_source);

static const char datavert_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"layout (location = 0) in vec2 texcoord;\n"
"out vec4 vPosition;\n"
"out vec4 vColor;\n"
"out vec4 vNormRad;\n"
"flat out int updateId;\n"
"uniform sampler2D cSampler;\n"
"uniform sampler2D drSampler;\n"
"uniform sampler2D drfSampler;\n"
"uniform usampler2D indexSampler;\n"
"uniform sampler2D vertConfSampler;\n"
"uniform sampler2D colorTimeSampler;\n"
"uniform sampler2D normRadSampler;\n"
"uniform vec4 cam; //cx, cy, 1/fx, 1/fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform float scale;\n"
"uniform float texDim;\n"
"uniform mat4 pose;\n"
"uniform float maxDepth;\n"
"uniform float time;\n"
"uniform float weighting;\n"
"float getRadius(float depth, float norm_z) {\n"
"    float meanFocal = ((1.0 / abs(cam.z)) + (1.0 / abs(cam.w))) / 2.0;\n"
"    \n"
"    const float sqrt2 = 1.41421356237f;\n"
"    \n"
"    float radius = (depth / meanFocal) * sqrt2;\n"
"    float radius_n = radius;\n"
"    radius_n = radius_n / abs(norm_z);\n"
"    radius_n = min(2.0f * radius, radius_n);\n"
"    return radius_n;\n"
"}\n"
"float confidence(float x, float y, float weighting) {\n"
"    const float maxRadDist = 400.0; //sqrt((width * 0.5)^2 + (height * 0.5)^2)\n"
"    const float twoSigmaSquared = 0.72; //2*(0.6^2) from paper\n"
"    vec2 pixelPosCentered = vec2(x, y) - cam.xy;\n"
"    float radialDist = sqrt(dot(pixelPosCentered, pixelPosCentered)) / maxRadDist;\n"
"    return exp((-(radialDist * radialDist) / twoSigmaSquared)) * weighting;\n"
"}\n"
"float encodeColor(vec3 c) {\n"
"    int rgb = int(round(c.x * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n"
"    return float(rgb);}\n"
"vec3 decodeColor(float c) {\n"
"    vec3 col;\n"
"    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n"
"    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n"
"    col.z = float(int(c) & 0xFF) / 255.0f;\n"
"    return col;}\n"
"//Central difference on floating point depth maps\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getVertex(vec2 texCoord, float x, float y, vec4 cam, sampler2D depth) {\n"
"    float z = float(textureLod(depth, texCoord, 0.0));\n"
"    return vec3((x - cam.x) * z * cam.z, (y - cam.y) * z * cam.w, z);\n"
"}\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getNormal(vec3 vPosition, vec2 texCoord, float x, float y, vec4 cam, sampler2D depth) {\n"
"    vec3 vPosition_xf = getVertex(vec2(texCoord.x + (1.0 / cols), texCoord.y), x + 1.0, y, cam, depth);\n"
"    vec3 vPosition_xb = getVertex(vec2(texCoord.x - (1.0 / cols), texCoord.y), x - 1.0, y, cam, depth);\n"
"    \n"
"    vec3 vPosition_yf = getVertex(vec2(texCoord.x, texCoord.y + (1.0 / rows)), x, y + 1.0, cam, depth);\n"
"    vec3 vPosition_yb = getVertex(vec2(texCoord.x, texCoord.y - (1.0 / rows)), x, y - 1.0, cam, depth);\n"
"    \n"
"    vec3 del_x = ((vPosition_xb + vPosition) / 2.0) - ((vPosition_xf + vPosition) / 2.0);\n"
"    vec3 del_y = ((vPosition_yb + vPosition) / 2.0) - ((vPosition_yf + vPosition) / 2.0);\n"
"    \n"
"    return normalize(cross(del_x, del_y));\n"
"}\n"
"//Forward difference on raw depth maps still in ushort mm\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getVertex(vec2 texcoord, int x, int y, vec4 cam, usampler2D depth) {\n"
"    float z = float(textureLod(depth, texcoord, 0.0)) / 1000.0f;\n"
"    return vec3((float(x) - cam.x) * z * cam.z, (float(y) - cam.y) * z * cam.w, z);\n"
"}\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getNormal(vec3 vPosition, vec2 texcoord, int x, int y, vec4 cam, usampler2D depth) {\n"
"    vec3 vPosition_x = getVertex(vec2(texcoord.x + (1.0 / cols), texcoord.y), x + 1, y, cam, depth);\n"
"    vec3 vPosition_y = getVertex(vec2(texcoord.x, texcoord.y + (1.0 / rows)), x, y + 1, cam, depth);\n"
"    \n"
"    vec3 del_x = vPosition_x - vPosition;\n"
"    vec3 del_y = vPosition_y - vPosition;\n"
"    \n"
"    return normalize(cross(del_x, del_y));\n"
"}\n"
"bool checkNeighbours(vec2 texCoord, sampler2D depth) {\n"
"    float z = float(textureLod(depth, vec2(texCoord.x - (1.0 / cols), texCoord.y), 0.0));\n"
"    if(z == 0.0)\n"
"        return false;\n"
"    z = float(textureLod(depth, vec2(texCoord.x, texCoord.y - (1.0 / rows)), 0.0));\n"
"    if(z == 0.0)\n"
"        return false;\n"
"    z = float(textureLod(depth, vec2(texCoord.x + (1.0 / cols), texCoord.y), 0.0));\n"
"    if(z == 0.0)\n"
"        return false;\n"
"    z = float(textureLod(depth, vec2(texCoord.x, texCoord.y + (1.0 / rows)), 0.0));\n"
"    if(z == 0.0)\n"
"        return false;\n"
"    return true;\n"
"}\n"
"float angleBetween(vec3 a, vec3 b) {\n"
"    return acos(dot(a, b) / (length(a) * length(b)));\n"
"}\n"
"void main() {\n"
"    //Should be guaranteed to be in bounds and centred on pixels\n"
"    float x = texcoord.x * cols;\n"
"    float y = texcoord.y * rows;\n"
"    //Vertex position integrated into model transformed to global coords\n"
"    vec3 vPosLocal = getVertex(texcoord.xy, x, y, cam, drSampler);\n"
"    vPosition = pose * vec4(vPosLocal, 1);\n"
"    //Filtered position ONLY used for normal and radius calculation\n"
"    vec3 vPosition_f = getVertex(texcoord.xy, x, y, cam, drfSampler);\n"
"    //Color for color, obviously\n"
"    vColor = textureLod(cSampler, texcoord.xy, 0.0);\n"
"    vColor.x = encodeColor(vColor.xyz);\n"
"    vColor.y = 0.0;\n"
"    vColor.z = time;\n"
"    //Normal and radius computed with filtered position / depth map transformed to global coords\n"
"    vec3 vNormLocal = getNormal(vPosition_f, texcoord.xy, x, y, cam, drfSampler);\n"
"    vNormRad = vec4(mat3(pose) * vNormLocal, getRadius(vPosition_f.z, vNormLocal.z));\n"
"    //Confidence\n"
"    vPosition.w = confidence(x, y, weighting);\n"
"    //Timestamp\n"
"    //We update this in update.vert, because it's used to signal new points later on\n"
"    vColor.w = 0.0;\n"
"    updateId = 0;\n"
"    uint best = 0U;\n"
"    //If this point is actually a valid vertex (i.e. has depth)\n"
"    if(int(x) % 2 == int(time) % 2 && int(y) % 2 == int(time) % 2 && \n"
"       checkNeighbours(texcoord.xy, drSampler) && vPosLocal.z > 0.0 && \n"
"       vPosLocal.z <= maxDepth) {\n"
"        int counter = 0;\n"
"        float indexXStep = (1.0f / (cols * scale)) * 0.5f;\n"
"        float indexYStep = (1.0f / (rows * scale)) * 0.5f;\n"
"        float bestDist = 1000.0;\n"
"        float windowMultiplier = 2.0;\n"
"        float xl = (x - cam.x) * cam.z;\n"
"        float yl = (y - cam.y) * cam.w;\n"
"        float lambda = sqrt(xl * xl + yl * yl + 1.0);\n"
"        vec3 ray = vec3(xl, yl, 1);\n"
"        for(float i = texcoord.x - (scale * indexXStep * windowMultiplier); i < texcoord.x + (scale * indexXStep * windowMultiplier); i += indexXStep) {\n"
"            for(float j = texcoord.y - (scale * indexYStep * windowMultiplier); j < texcoord.y + (scale * indexYStep * windowMultiplier); j += indexYStep) {\n"
"               uint current = uint(textureLod(indexSampler, vec2(i, j), 0.0));\n"
"               if(current > 0U) {\n"
"                   vec4 vertConf = textureLod(vertConfSampler, vec2(i, j), 0.0);\n"
"                   if(abs((vertConf.z * lambda) - (vPosLocal.z * lambda)) < 0.05) {\n"
"                       float dist = length(cross(ray, vertConf.xyz)) / length(ray);\n"
"                       vec4 normRad = textureLod(normRadSampler, vec2(i, j), 0.0);\n"
"                       if(dist < bestDist && (abs(normRad.z) < 0.75f || abs(angleBetween(normRad.xyz, vNormLocal.xyz)) < 0.5f)) {\n"
"                           counter++;\n"
"                           bestDist = dist;\n"
"                           best = current;\n"
"                       }\n"
"                   }\n"
"               }\n"
"            }\n"
"        }\n"
"        //We found a point to merge with\n"
"        if(counter > 0) {\n"
"           updateId = 1;\n"
"           vColor.w = -1.0;\n"
"        } else  {\n"
"           //New unstable vertex\n"
"           updateId = 2;\n"
"           vColor.w = -2.0;\n"
"        }\n"
"    }\n"
"    //Output vertex id of the existing point to update\n"
"    if(updateId == 1) {\n"
"        uint intY = best / uint(texDim);\n"
"        uint intX = best - (intY * uint(texDim));\n"
"        float halfPixel = 0.5 * (1.0f / texDim);\n"
"        //should set gl_Position here to the 2D index for the updated vertex ID\n"
"        gl_Position = vec4(float(int(intX) - (int(texDim) / 2)) / (texDim / 2.0) + halfPixel, \n"
"                           float(int(intY) - (int(texDim) / 2)) / (texDim / 2.0) + halfPixel, \n"
"                           0, \n"
"                           1.0);\n"
"    } else {\n"
"        //Either don't render anything, or output a new unstable vertex offscreen\n"
"        gl_Position = vec4(-10, -10, 0, 1);\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> datavert_tuple = std::make_tuple("datavert", datavert_source);

static const char depth_bilateralfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"in vec2 texcoord;\n"
"out uint FragColor;\n"
"uniform usampler2D gSampler;\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform float maxD;\n"
"void main() {\n"
"    uint value = uint(texture(gSampler, texcoord.xy));\n"
"    if(value > uint(maxD * 1000.0f) || value < 300U) {\n"
"        FragColor = 0U;\n"
"    } else {\n"
"      int x = int(texcoord.x * cols);\n"
"      int y = int(texcoord.y * rows);\n"
"      const float sigma_space2_inv_half = 0.024691358; // 0.5 / (sigma_space * sigma_space)\n"
"      const float sigma_color2_inv_half = 0.000555556; // 0.5 / (sigma_color * sigma_color)\n"
"      const int R = 6;\n"
"      const int D = R * 2 + 1;\n"
"      int tx = min(x - D / 2 + D, int(cols));\n"
"      int ty = min(y - D / 2 + D, int(rows));\n"
"      float sum1 = 0.0;\n"
"      float sum2 = 0.0;\n"
"      for(int cy = max(y - D / 2, 0); cy < ty; ++cy) {\n"
"          for(int cx = max(x - D / 2, 0); cx < tx; ++cx) {\n"
"              float texX = float(cx) / cols;\n"
"              float texY = float(cy) / rows;\n"
"              uint tmp = uint(texture(gSampler, vec2(texX, texY)));\n"
"              if (tmp > 0U && tmp < uint(maxD * 1000.0f)) {\n"
"                float space2 = (float(x) - float(cx)) * (float(x) - float(cx)) + (float(y) - float(cy)) * (float(y) - float(cy));\n"
"                float color2 = (float(value) - float(tmp)) * (float(value) - float(tmp));\n"
"                float weight = exp(-(space2 * sigma_space2_inv_half + color2 * sigma_color2_inv_half));\n"
"                sum1 += float(tmp) * weight;\n"
"                sum2 += weight;\n"
"              }\n"
"          }\n"
"      }\n"
"    if (sum2 > 0.0)\n"
"        FragColor = uint(round(sum1/sum2));\n"
"    else\n"
"      FragColor = 0U;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> depth_bilateralfrag_tuple = std::make_tuple("depth_bilateralfrag", depth_bilateralfrag_source);

static const char depth_metricfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"in vec2 texcoord;\n"
"out float FragColor;\n"
"uniform usampler2D gSampler;\n"
"uniform float maxD;\n"
"void main() {\n"
"    uint value = uint(texture(gSampler, texcoord.xy));\n"
"    if(value > uint(maxD * 1000.0f) || value < 300U) {\n"
"        FragColor = 0.0;\n"
"    } else {\n"
"      FragColor = float(value) / 1000.0f;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> depth_metricfrag_tuple = std::make_tuple("depth_metricfrag", depth_metricfrag_source);

static const char depth_normfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"in vec2 texcoord;\n"
"out float FragColor;\n"
"uniform usampler2D gSampler;\n"
"uniform float minVal;\n"
"uniform float maxVal;\n"
"void main() {\n"
"    uint value = uint(texture(gSampler, texcoord.xy));\n"
"    if(value > uint(minVal) && value < uint(maxVal))\n"
"        FragColor = 1.0f - (float(value) / maxVal);\n"
"    else \n"
"        FragColor = 0.0;\n"
"}\n";
static const std::tuple<std::string, std::string> depth_normfrag_tuple = std::make_tuple("depth_normfrag", depth_normfrag_source);

static const char depth_splatfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"uniform vec4 cam; //cx, cy, fx, fy\n"
"uniform float maxDepth;\n"
"in vec4 position;\n"
"in vec4 normRad;\n"
"out float FragColor;\n"
"void main() {\n"
"    vec3 l = normalize(vec3((vec2(gl_FragCoord) - cam.xy) / cam.zw, 1.0f));\n"
"    vec3 corrected_pos = (dot(position.xyz, normRad.xyz) / dot(l, normRad.xyz)) * l; \n"
"    //check if the intersection is inside the surfel\n"
"    float sqrRad = pow(normRad.w, 2.0);\n"
"    vec3 diff = corrected_pos - position.xyz;\n"
"    if(dot(diff, diff) > sqrRad) { discard; }\n"
"    FragColor = corrected_pos.z;\n"
"    gl_FragDepth = (corrected_pos.z / (2.0 * maxDepth)) + 0.5f;\n"
"}\n";
static const std::tuple<std::string, std::string> depth_splatfrag_tuple = std::make_tuple("depth_splatfrag", depth_splatfrag_source);

static const char draw_feedbackfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 vColor;\n"
"out vec4 FragColor;\n"
"void main() {\n"
"    FragColor = vColor;\n"
"}\n";
static const std::tuple<std::string, std::string> draw_feedbackfrag_tuple = std::make_tuple("draw_feedbackfrag", draw_feedbackfrag_source);

static const char draw_feedbackvert_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 color;\n"
"layout (location = 2) in vec4 normal;\n"
"uniform mat4 MVP;\n"
"uniform mat4 pose;\n"
"uniform float threshold;\n"
"uniform int colorType;\n"
"out vec4 vColor;\n"
"float encodeColor(vec3 c) {\n"
"    int rgb = int(round(c.x * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n"
"    return float(rgb);}\n"
"vec3 decodeColor(float c) {\n"
"    vec3 col;\n"
"    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n"
"    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n"
"    col.z = float(int(c) & 0xFF) / 255.0f;\n"
"    return col;}\n"
"void main() {\n"
"    if(position.w > threshold) {\n"
"        if(colorType == 1) {\n"
"            vColor = vec4(normal.xyz, 1.0);\n"
"        } else if(colorType == 2) {\n"
"            vColor = vec4(decodeColor(color.x), 1.0);\n"
"        } else {\n"
"            vColor = vec4((vec3(.5f, .5f, .5f) * abs(dot(normal.xyz, vec3(1.0, 1.0, 1.0)))) + vec3(0.1f, 0.1f, 0.1f), 1.0f);\n"
"        }\n"
"        gl_Position = MVP * pose * vec4(position.xyz, 1.0);\n"
"    } else {\n"
"        gl_Position = vec4(-10, -10, 0, 1);\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> draw_feedbackvert_tuple = std::make_tuple("draw_feedbackvert", draw_feedbackvert_source);

static const char draw_global_surfacefrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec3 vColor0;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"void main() {\n"
"    if(dot(texcoord, texcoord) > 1.0)\n"
"        discard;\n"
"    FragColor = vec4(vColor0, 1.0f);\n"
"}\n";
static const std::tuple<std::string, std::string> draw_global_surfacefrag_tuple = std::make_tuple("draw_global_surfacefrag", draw_global_surfacefrag_source);

static const char draw_global_surfacegeom_source []=
"#version 310 es\n"
"#extension GL_EXT_geometry_shader : require\n"
"precision highp float;\n"
"precision highp int;\n"
"layout(points) in;\n"
"layout(triangle_strip, max_vertices = 4) out;\n"
"uniform float threshold;\n"
"uniform float signMult;\n"
"in vec4 vColor[];\n"
"in vec4 vPosition[];\n"
"in vec4 vNormRad[];\n"
"in mat4 vMVP[];\n"
"in int colorType0[];\n"
"in int drawWindow0[];\n"
"in int vTime[];\n"
"in int timeDelta0[];\n"
"out vec3 vColor0;\n"
"out vec3 v;\n"
"out vec3 n;\n"
"out vec2 texcoord;\n"
"float encodeColor(vec3 c) {\n"
"    int rgb = int(round(c.x * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n"
"    return float(rgb);}\n"
"vec3 decodeColor(float c) {\n"
"    vec3 col;\n"
"    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n"
"    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n"
"    col.z = float(int(c) & 0xFF) / 255.0f;\n"
"    return col;}\n"
"void main() {\n"
"    if(colorType0[0] != -1) {\n"
"        if(colorType0[0] == 1) {\n"
"            vColor0 = vNormRad[0].xyz;\n"
"        } else if(colorType0[0] == 2) {\n"
"            vColor0 = decodeColor(vColor[0].x);\n"
"        } else if(colorType0[0] == 3 || vPosition[0].w <= threshold) {\n"
"            vColor0 = vec3(vColor[0].z / float(vTime[0]));\n"
"            float minimum = 1.0f;\n"
"            float maximum = float(vTime[0]);\n"
"            float ratio = 2.0 * (vColor[0].z - minimum) / (maximum - minimum);\n"
"            vColor0.x = max(0.0, (1.0 - ratio));\n"
"            vColor0.y = max(0.0, (ratio - 1.0));\n"
"            vColor0.z = 1.0f - vColor0.x - vColor0.y;\n"
"            vColor0.xyz *= abs(dot(vNormRad[0].xyz, vec3(1.0, 1.0, 1.0))) + vec3(0.1f, 0.1f, 0.1f);\n"
"        } else  {\n"
"            vColor0 = (vec3(.5f, .5f, .5f) * abs(dot(vNormRad[0].xyz, vec3(1.0, 1.0, 1.0)))) + vec3(0.1f, 0.1f, 0.1f);\n"
"        }\n"
"        if(float(drawWindow0[0]) == 1.0 && float(vTime[0]) - vColor[0].w > float(timeDelta0[0])) {\n"
"            vColor0 *= 0.25;\n"
"        }\n"
"        vec3 x = normalize(vec3((vNormRad[0].y - vNormRad[0].z), -vNormRad[0].x, vNormRad[0].x)) * vNormRad[0].w * 1.41421356;\n"
"        vec3 y = cross(vNormRad[0].xyz, x);\n"
"        n = signMult * vNormRad[0].xyz;\n"
"        texcoord = vec2(-1.0, -1.0);\n"
"        gl_Position = vMVP[0] * vec4(vPosition[0].xyz + x, 1.0);\n"
"        v = vPosition[0].xyz + x;\n"
"        EmitVertex();\n"
"        texcoord = vec2(1.0, -1.0);\n"
"        gl_Position = vMVP[0] * vec4(vPosition[0].xyz + y, 1.0);\n"
"        v = vPosition[0].xyz + y;\n"
"        EmitVertex();\n"
"        texcoord = vec2(-1.0, 1.0);\n"
"        gl_Position = vMVP[0] * vec4(vPosition[0].xyz - y, 1.0);\n"
"        v = vPosition[0].xyz - y;\n"
"        EmitVertex();\n"
"        texcoord = vec2(1.0, 1.0);\n"
"        gl_Position = vMVP[0] * vec4(vPosition[0].xyz - x, 1.0);\n"
"        v = vPosition[0].xyz - x;\n"
"        EmitVertex();\n"
"        EndPrimitive();\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> draw_global_surfacegeom_tuple = std::make_tuple("draw_global_surfacegeom", draw_global_surfacegeom_source);

static const char draw_global_surfacevert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 color;\n"
"layout (location = 2) in vec4 normal;\n"
"uniform mat4 MVP;\n"
"uniform float threshold;\n"
"uniform int colorType;\n"
"uniform int unstable;\n"
"uniform int drawWindow;\n"
"uniform int time;\n"
"uniform int timeDelta;\n"
"out vec4 vColor;\n"
"out vec4 vPosition;\n"
"out vec4 vNormRad;\n"
"out mat4 vMVP;\n"
"out int vTime;\n"
"out int colorType0;\n"
"out int drawWindow0;\n"
"out int timeDelta0;\n"
"void main() {\n"
"    if(position.w > threshold || unstable == 1) {\n"
"        colorType0 = colorType;\n"
"        drawWindow0 = drawWindow;\n"
"        vColor = color;\n"
"        vPosition = position;\n"
"        vNormRad = normal;\n"
"        vMVP = MVP;\n"
"        vTime = time;\n"
"        timeDelta0 = timeDelta;\n"
"        gl_Position = MVP * vec4(position.xyz, 1.0);\n"
"    } else {\n"
"        colorType0 = -1;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> draw_global_surfacevert_tuple = std::make_tuple("draw_global_surfacevert", draw_global_surfacevert_source);

static const char draw_global_surface_phongfrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec3 n;\n"
"in vec3 v;\n"
"in vec3 vColor0;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"uniform vec3 lightpos;\n"
"void main() {\n"
"    if(dot(texcoord, texcoord) > 1.0)\n"
"        discard;\n"
"    vec4 diffuse = vec4(0.0);\n"
"    vec4 specular = vec4(0.0);\n"
"    // ambient term\n"
"    vec4 ambient = vec4(0.3 * vColor0, 1);\n"
"    // diffuse color\n"
"    vec4 kd = vec4(vColor0, 1.0);\n"
"    // specular color\n"
"    vec4 ks = vec4(1.0, 1.0, 1.0, 1.0);\n"
"    // diffuse term\n"
"    vec3 lightDir = normalize(lightpos - v);\n"
"    float NdotL = dot(n, lightDir);\n"
"    if (NdotL > 0.0)\n"
"        diffuse = kd * NdotL;\n"
"    // specular term\n"
"    vec3 rVector = normalize(2.0 * n * dot(n, lightDir) - lightDir);\n"
"    vec3 viewVector = normalize(-v);\n"
"    float RdotV = dot(rVector, viewVector);\n"
"    if (RdotV > 0.0)\n"
"        specular = ks * pow(RdotV, 32);\n"
"    FragColor = ambient + diffuse + specular;\n"
"}\n";
static const std::tuple<std::string, std::string> draw_global_surface_phongfrag_tuple = std::make_tuple("draw_global_surface_phongfrag", draw_global_surface_phongfrag_source);

static const char emptyvert_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"void main() {}\n";
static const std::tuple<std::string, std::string> emptyvert_tuple = std::make_tuple("emptyvert", emptyvert_source);

static const char fill_normalfrag_source[]=
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"uniform sampler2D eSampler;\n"
"uniform usampler2D rSampler;\n"
"uniform vec4 cam; //cx, cy, 1/fx, 1/fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform int passthrough;\n"
"//Central difference on floating point depth maps\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getVertex(vec2 texCoord, float x, float y, vec4 cam, sampler2D depth) {\n"
"    float z = float(textureLod(depth, texCoord, 0.0));\n"
"    return vec3((x - cam.x) * z * cam.z, (y - cam.y) * z * cam.w, z);\n"
"}\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getNormal(vec3 vPosition, vec2 texCoord, float x, float y, vec4 cam, sampler2D depth) {\n"
"    vec3 vPosition_xf = getVertex(vec2(texCoord.x + (1.0 / cols), texCoord.y), x + 1.0, y, cam, depth);\n"
"    vec3 vPosition_xb = getVertex(vec2(texCoord.x - (1.0 / cols), texCoord.y), x - 1.0, y, cam, depth);\n"
"    \n"
"    vec3 vPosition_yf = getVertex(vec2(texCoord.x, texCoord.y + (1.0 / rows)), x, y + 1.0, cam, depth);\n"
"    vec3 vPosition_yb = getVertex(vec2(texCoord.x, texCoord.y - (1.0 / rows)), x, y - 1.0, cam, depth);\n"
"    \n"
"    vec3 del_x = ((vPosition_xb + vPosition) / 2.0) - ((vPosition_xf + vPosition) / 2.0);\n"
"    vec3 del_y = ((vPosition_yb + vPosition) / 2.0) - ((vPosition_yf + vPosition) / 2.0);\n"
"    \n"
"    return normalize(cross(del_x, del_y));\n"
"}\n"
"//Forward difference on raw depth maps still in ushort mm\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getVertex(vec2 texcoord, int x, int y, vec4 cam, usampler2D depth) {\n"
"    float z = float(textureLod(depth, texcoord, 0.0)) / 1000.0f;\n"
"    return vec3((float(x) - cam.x) * z * cam.z, (float(y) - cam.y) * z * cam.w, z);\n"
"}\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getNormal(vec3 vPosition, vec2 texcoord, int x, int y, vec4 cam, usampler2D depth) {\n"
"    vec3 vPosition_x = getVertex(vec2(texcoord.x + (1.0 / cols), texcoord.y), x + 1, y, cam, depth);\n"
"    vec3 vPosition_y = getVertex(vec2(texcoord.x, texcoord.y + (1.0 / rows)), x, y + 1, cam, depth);\n"
"    \n"
"    vec3 del_x = vPosition_x - vPosition;\n"
"    vec3 del_y = vPosition_y - vPosition;\n"
"    \n"
"    return normalize(cross(del_x, del_y));\n"
"}\n"
"void main() {\n"
"    float halfPixX = 0.5 * (1.0 / cols);\n"
"    float halfPixY = 0.5 * (1.0 / rows);\n"
"     vec4 samp = textureLod(eSampler, texcoord, 0.0);\n"
"    if(samp.z == 0.0 || passthrough == 1) {\n"
"        vec4 vPos = vec4(getVertex(texcoord, int(texcoord.x * cols), int(texcoord.y * rows), cam, rSampler), 1);\n"
"        FragColor = vec4(getNormal(vPos.xyz, texcoord, int(texcoord.x * cols), int(texcoord.y * rows), cam, rSampler), 1);\n"
"    } else {\n"
"        FragColor = samp;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> fill_normalfrag_tuple = std::make_tuple("fill_normalfrag", fill_normalfrag_source);

static const char fill_rgbfrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"uniform sampler2D eSampler;\n"
"uniform sampler2D rSampler;\n"
"uniform int passthrough;\n"
"void main() {\n"
"    vec4 samp = texture(eSampler, texcoord.xy);\n"
"    if(samp.x + samp.y + samp.z == 0.0 || passthrough == 1)\n"
"        FragColor = texture(rSampler, texcoord.xy);\n"
"    else\n"
"        FragColor = samp;\n"
"}\n";
static const std::tuple<std::string, std::string> fill_rgbfrag_tuple = std::make_tuple("fill_rgbfrag", fill_rgbfrag_source);

static const char fill_vertexfrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"precision lowp sampler2D;\n"
"precision lowp samplerCube;\n"
"precision lowp usampler2D;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"uniform sampler2D eSampler;\n"
"uniform usampler2D rSampler;\n"
"uniform vec4 cam; //cx, cy, 1/fx, 1/fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform int passthrough;\n"
"vec3 getVertex(int x, int y, float z) {\n"
"    return vec3((float(x) - cam.x) * z * cam.z, (float(y) - cam.y) * z * cam.w, z);\n"
"}\n"
"void main() {\n"
"    float halfPixX = 0.5 * (1.0 / cols);\n"
"    float halfPixY = 0.5 * (1.0 / rows);\n"
"    vec4 samp = textureLod(eSampler, texcoord, 0.0);\n"
"    if(samp.z == 0.0 || passthrough == 1) {\n"
"        float z = float(textureLod(rSampler, texcoord, 0.0)) / 1000.0f;\n"
"        FragColor = vec4(getVertex(int(texcoord.x * cols), int(texcoord.y * rows), z), 1);\n"
"    } else {\n"
"        FragColor = samp;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> fill_vertexfrag_tuple = std::make_tuple("fill_vertexfrag", fill_vertexfrag_source);

static const char fxaafrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
"#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
"#define FXAA_SPAN_MAX     8.0\n"
"uniform sampler2D tex;\n"
"uniform vec2 resolution;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"void main() {\n"
"    vec4 color;\n"
"    vec2 inverseVP = 1.0 / resolution.xy;\n"
"    vec2 v_rgbNW = texcoord + (vec2(-1.0, -1.0) * inverseVP);\n"
"    vec2 v_rgbNE = texcoord + (vec2(1.0, -1.0) * inverseVP);\n"
"    vec2 v_rgbSW = texcoord + (vec2(-1.0, 1.0) * inverseVP);\n"
"    vec2 v_rgbSE = texcoord + (vec2(1.0, 1.0) * inverseVP);\n"
"    vec2 v_rgbN = texcoord + (vec2(-1.0, 0.0) * inverseVP);\n"
"    vec2 v_rgbE = texcoord + (vec2(1.0, 0.0) * inverseVP);\n"
"    vec2 v_rgbW = texcoord + (vec2(0.0, -1.0) * inverseVP);\n"
"    vec2 v_rgbS = texcoord + (vec2(0.0, 1.0) * inverseVP);\n"
"    vec2 v_rgbM = texcoord;\n"
"    vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n"
"    vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n"
"    vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n"
"    vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n"
"    vec3 rgbN = texture(tex, v_rgbN).xyz;\n"
"    vec3 rgbE = texture(tex, v_rgbE).xyz;\n"
"    vec3 rgbW = texture(tex, v_rgbW).xyz;\n"
"    vec3 rgbS = texture(tex, v_rgbS).xyz;\n"
"    vec3 rgbM  = texture(tex, v_rgbM).xyz;\n"
"    vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"    float lumaNW = dot(rgbNW, luma);\n"
"    float lumaNE = dot(rgbNE, luma);\n"
"    float lumaSW = dot(rgbSW, luma);\n"
"    float lumaSE = dot(rgbSE, luma);\n"
"    float lumaM  = dot(rgbM,  luma);\n"
"    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"    vec2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
"    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n"
"    vec3 rgbA = 0.5 * (texture(tex, texcoord + dir * (1.0 / 3.0 - 0.5)).xyz + texture(tex, texcoord + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
"    vec3 rgbB = rgbA * 0.5 + 0.25 * (texture(tex, texcoord + dir * -0.5).xyz + texture(tex, texcoord + dir * 0.5).xyz);\n"
"    float lumaB = dot(rgbB, luma);\n"
"    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"        FragColor = vec4(rgbA, 1);\n"
"    else\n"
"        FragColor = vec4(rgbB, 1);\n"
"}\n";
static const std::tuple<std::string, std::string> fxaafrag_tuple = std::make_tuple("fxaafrag", fxaafrag_source);

static const char index_mapfrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 vPosition0;\n"
"in vec4 vColorTime0;\n"
"in vec4 vNormRad0;\n"
"flat in int vertexId;\n"
"layout(location = 0) out int FragColor;\n"
"layout(location = 1) out vec4 vPosition1;\n"
"layout(location = 2) out vec4 vColorTime1;\n"
"layout(location = 3) out vec4 vNormRad1;\n"
"void main() {\n"
"    vPosition1 = vPosition0;\n"
"    vColorTime1 = vColorTime0;\n"
"    vNormRad1 = vNormRad0; \n"
"    FragColor = vertexId;\n"
"}\n";
static const std::tuple<std::string, std::string> index_mapfrag_tuple = std::make_tuple("index_mapfrag", index_mapfrag_source);

static const char index_mapvert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 vPosition;\n"
"layout (location = 1) in vec4 vColorTime;\n"
"layout (location = 2) in vec4 vNormRad;\n"
"out vec4 vPosition0;\n"
"out vec4 vColorTime0;\n"
"out vec4 vNormRad0;\n"
"flat out int vertexId;\n"
"uniform mat4 t_inv;\n"
"uniform vec4 cam; //cx, cy, fx, fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform float maxDepth;\n"
"uniform int time;\n"
"uniform int timeDelta;\n"
"void main() {\n"
"    vec4 vPosHome = t_inv * vec4(vPosition.xyz, 1.0);\n"
"    float x = 0.0;\n"
"    float y = 0.0;\n"
"    if(vPosHome.z > maxDepth || vPosHome.z < 0.0 || float(time) - vColorTime.w > float(timeDelta)) {\n"
"        x = -10.0;\n"
"        y = -10.0;\n"
"        vertexId = 0;\n"
"    } else {\n"
"        x = ((((cam.z * vPosHome.x) / vPosHome.z) + cam.x) - (cols * 0.5)) / (cols * 0.5);\n"
"        y = ((((cam.w * vPosHome.y) / vPosHome.z) + cam.y) - (rows * 0.5)) / (rows * 0.5);\n"
"        vertexId = gl_VertexID;\n"
"    }\n"
"    gl_Position = vec4(x, y, vPosHome.z / maxDepth, 1.0);\n"
"    vPosition0 = vec4(vPosHome.xyz, vPosition.w);\n"
"    vColorTime0 = vColorTime;\n"
"    vNormRad0 = vec4(normalize(mat3(t_inv) * vNormRad.xyz), vNormRad.w);\n"
"}\n";
static const std::tuple<std::string, std::string> index_mapvert_tuple = std::make_tuple("index_mapvert", index_mapvert_source);

static const char init_unstablevert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 vPosition;\n"
"layout (location = 1) in vec4 vColor;\n"
"layout (location = 2) in vec4 vNormRad;\n"
"out vec4 vPosition0;\n"
"out vec4 vColor0;\n"
"out vec4 vNormRad0;\n"
"void main() {\n"
"    vPosition0 = vPosition;\n"
"    vColor0 = vColor;\n"
"    vColor0.y = 0.0; //Unused\n"
"    vColor0.z = 1.0; //This sets the vertex's initialisation time\n"
"    vNormRad0 = vNormRad;\n"
"}\n";
static const std::tuple<std::string, std::string> init_unstablevert_tuple = std::make_tuple("init_unstablevert", init_unstablevert_source);

static const char quadgeom_source[] =
"#version 310 es\n"
"#extension GL_EXT_geometry_shader : require\n"
"precision highp float;\n"
"precision highp int;\n"
"layout(points) in;\n"
"layout(triangle_strip, max_vertices = 4) out;\n"
"out vec2 texcoord;\n"
"void main() {\n"
"    gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n"
"    texcoord = vec2(1.0, 1.0);\n"
"    EmitVertex();\n"
"    gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n"
"    texcoord = vec2(0.0, 1.0); \n"
"    EmitVertex();\n"
"    gl_Position = vec4(1.0,-1.0, 0.0, 1.0);\n"
"    texcoord = vec2(1.0, 0.0); \n"
"    EmitVertex();\n"
"    gl_Position = vec4(-1.0,-1.0, 0.0, 1.0);\n"
"    texcoord = vec2(0.0, 0.0); \n"
"    EmitVertex();\n"
"    EndPrimitive(); \n"
"}\n";
static const std::tuple<std::string, std::string> quadgeom_tuple = std::make_tuple("quadgeom", quadgeom_source);

static const char resizefrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"uniform sampler2D eSampler;\n"
"void main() {\n"
"    FragColor = texture(eSampler, texcoord.xy);\n"
"}\n";
static const std::tuple<std::string, std::string> resizefrag_tuple = std::make_tuple("resizefrag", resizefrag_source);

static const char samplegeom_source[] =
"#version 310 es\n"
"#extension GL_EXT_geometry_shader : require\n"
"precision highp float;\n"
"precision highp int;\n"
"layout(points) in;\n"
"layout(points, max_vertices = 1) out;\n"
"in vec4 vPosition0[];\n"
"in vec4 vColorTime0[];\n"
"in vec4 vNormRad0[];\n"
"flat in int id[];\n"
"out vec4 vData;\n"
"void main() {\n"
"    if(id[0] % 5000 == 0) {\n"
"        vData.xyz = vPosition0[0].xyz;\n"
"        vData.w = vColorTime0[0].z;\n"
"        EmitVertex();\n"
"        EndPrimitive(); \n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> samplegeom_tuple = std::make_tuple("samplegeom", samplegeom_source);

static const char samplevert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 vPosition;\n"
"layout (location = 1) in vec4 vColorTime;\n"
"layout (location = 2) in vec4 vNormRad;\n"
"out vec4 vPosition0;\n"
"out vec4 vColorTime0;\n"
"out vec4 vNormRad0;\n"
"flat out int id;\n"
"void main() {\n"
"    vPosition0 = vPosition;\n"
"    vColorTime0 = vColorTime;\n"
"    vNormRad0 = vNormRad;\n"
"    id = gl_VertexID;    \n"
"}\n";
static const std::tuple<std::string, std::string> samplevert_tuple = std::make_tuple("samplevert", samplevert_source);

static const char splatvert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 vPosition;\n"
"layout (location = 1) in vec4 vColor;\n"
"layout (location = 2) in vec4 vNormRad;\n"
"uniform mat4 t_inv;\n"
"uniform vec4 cam; //cx, cy, fx, fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform float maxDepth;\n"
"uniform float confThreshold;\n"
"uniform int time;\n"
"uniform int maxTime;\n"
"uniform int timeDelta;\n"
"out vec4 position;\n"
"out vec4 normRad;\n"
"out vec4 colTime;\n"
"vec3 projectPoint(vec3 p) {\n"
"    return vec3(((((cam.z * p.x) / p.z) + cam.x) - (cols * 0.5)) / (cols * 0.5),\n"
"                ((((cam.w * p.y) / p.z) + cam.y) - (rows * 0.5)) / (rows * 0.5),\n"
"                p.z / maxDepth);\n"
"}\n"
"vec3 projectPointImage(vec3 p) {\n"
"    return vec3(((cam.z * p.x) / p.z) + cam.x,\n"
"                ((cam.w * p.y) / p.z) + cam.y,\n"
"                p.z);\n"
"}\n"
"void main() {\n"
"    vec4 vPosHome = t_inv * vec4(vPosition.xyz, 1.0);\n"
"    if(vPosHome.z > maxDepth || vPosHome.z < 0.0 || vPosition.w < confThreshold || float(time) - vColor.w > float(timeDelta) || vColor.w > float(maxTime)) {\n"
"        gl_Position = vec4(1000.0f, 1000.0f, 1000.0f, 1000.0f);\n"
"        gl_PointSize = 0.0;\n"
"    } else {\n"
"        gl_Position = vec4(projectPoint(vPosHome.xyz), 1.0);\n"
"        colTime = vColor;\n"
"        position = vec4(vPosHome.xyz, vPosition.w);\n"
"        normRad = vec4(normalize(mat3(t_inv) * vNormRad.xyz), vNormRad.w);\n"
"        vec3 x1 = normalize(vec3((normRad.y - normRad.z), -normRad.x, normRad.x)) * normRad.w * 1.41421356;\n"
"        vec3 y1 = cross(normRad.xyz, x1);\n"
"        vec4 proj1 = vec4(projectPointImage(vPosHome.xyz + x1), 1.0);\n"
"        vec4 proj2 = vec4(projectPointImage(vPosHome.xyz + y1), 1.0);\n"
"        vec4 proj3 = vec4(projectPointImage(vPosHome.xyz - y1), 1.0);\n"
"        vec4 proj4 = vec4(projectPointImage(vPosHome.xyz - x1), 1.0);\n"
"        vec2 xs = vec2(min(proj1.x, min(proj2.x, min(proj3.x, proj4.x))), max(proj1.x, max(proj2.x, max(proj3.x, proj4.x))));\n"
"        vec2 ys = vec2(min(proj1.y, min(proj2.y, min(proj3.y, proj4.y))), max(proj1.y, max(proj2.y, max(proj3.y, proj4.y))));\n"
"        float xDiff = abs(xs.y - xs.x);\n"
"        float yDiff = abs(ys.y - ys.x);\n"
"        gl_PointSize = max(0.0, max(xDiff, yDiff));\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> splatvert_tuple = std::make_tuple("splatvert", splatvert_source);

static const char updatevert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec4 vPosition;\n"
"layout (location = 1) in vec4 vColor;\n"
"layout (location = 2) in vec4 vNormRad;\n"
"out vec4 vPosition0;\n"
"out vec4 vColor0;\n"
"out vec4 vNormRad0;\n"
"uniform float texDim;\n"
"uniform int time;\n"
"uniform sampler2D vertSamp;\n"
"uniform sampler2D colorSamp;\n"
"uniform sampler2D normSamp;\n"
"float encodeColor(vec3 c) {\n"
"    int rgb = int(round(c.x * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n"
"    return float(rgb);}\n"
"vec3 decodeColor(float c) {\n"
"    vec3 col;\n"
"    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n"
"    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n"
"    col.z = float(int(c) & 0xFF) / 255.0f;\n"
"    return col;}\n"
"void main() {\n"
"    int intY = gl_VertexID / int(texDim);\n"
"    int intX = gl_VertexID - (intY * int(texDim));\n"
"    float halfPixel = 0.5 * (1.0f / texDim);\n"
"    float y = (float(intY) / texDim) + halfPixel;\n"
"    float x = (float(intX) / texDim) + halfPixel;\n"
"    vec4 newColor = textureLod(colorSamp, vec2(x, y), 0.0);\n"
"    //Do averaging here\n"
"    if(newColor.w == -1.0) {\n"
"        vec4 newPos = textureLod(vertSamp, vec2(x, y), 0.0);\n"
"        vec4 newNorm = textureLod(normSamp, vec2(x, y), 0.0);\n"
"        float c_k = vPosition.w;\n"
"        vec3 v_k = vPosition.xyz;\n"
"        float a = newPos.w;\n"
"        vec3 v_g = newPos.xyz;\n"
"        if(newNorm.w < (1.0 + 0.5) * vNormRad.w) {\n"
"            vPosition0 = vec4(((c_k * v_k) + (a * v_g)) / (c_k + a), c_k + a);\n"
"            vec3 oldCol = decodeColor(vColor.x);\n"
"            vec3 newCol = decodeColor(newColor.x);\n"
"            vec3 avgColor = ((c_k * oldCol.xyz) + (a * newCol.xyz)) / (c_k + a);\n"
"            vColor0 = vec4(encodeColor(avgColor), vColor.y, vColor.z, time);\n"
"            vNormRad0 = ((c_k * vNormRad) + (a * newNorm)) / (c_k + a);\n"
"            vNormRad0.xyz = normalize(vNormRad0.xyz);\n"
"        } else {\n"
"            vPosition0 = vPosition;\n"
"            vColor0 = vColor;\n"
"            vNormRad0 = vNormRad;\n"
"            vPosition0.w = c_k + a;\n"
"            vColor0.w = float(time);\n"
"        }\n"
"    } else {\n"
"        //This point isn't being updated, so just transfer it\n"
"        vPosition0 = vPosition;\n"
"        vColor0 = vColor;\n"
"        vNormRad0 = vNormRad;\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> updatevert_tuple = std::make_tuple("updatevert", updatevert_source);

static const char vertex_feedbackgeom_source[] =
"#version 310 es\n"
"#extension GL_EXT_geometry_shader : require\n"
"precision highp float;\n"
"precision highp int;\n"
"layout(points) in;\n"
"layout(points, max_vertices = 1) out;\n"
"in vec4 vPosition[];\n"
"in vec4 vColor[];\n"
"in vec4 vNormRad[];\n"
"in float zVal[];\n"
"out vec4 vPosition0;\n"
"out vec4 vColor0;\n"
"out vec4 vNormRad0;\n"
"void main() {\n"
"    if(zVal[0] > 0.0) {\n"
"        vPosition0 = vPosition[0];\n"
"        vColor0 = vColor[0];\n"
"        vNormRad0 = vNormRad[0];\n"
"        EmitVertex();\n"
"        EndPrimitive(); \n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> vertex_feedbackgeom_tuple = std::make_tuple("vertex_feedbackgeom", vertex_feedbackgeom_source);

static const char vertex_feedbackvert_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"layout (location = 0) in vec2 texcoord;\n"
"out vec4 vPosition;\n"
"out vec4 vColor;\n"
"out vec4 vNormRad;\n"
"out float zVal;\n"
"uniform sampler2D gSampler;\n"
"uniform sampler2D cSampler;\n"
"uniform vec4 cam; //cx, cy, 1/fx, 1/fy\n"
"uniform float cols;\n"
"uniform float rows;\n"
"uniform int time;\n"
"uniform float maxDepth;\n"
"float getRadius(float depth, float norm_z) {\n"
"    float meanFocal = ((1.0 / abs(cam.z)) + (1.0 / abs(cam.w))) / 2.0;\n"
"    \n"
"    const float sqrt2 = 1.41421356237f;\n"
"    \n"
"    float radius = (depth / meanFocal) * sqrt2;\n"
"    float radius_n = radius;\n"
"    radius_n = radius_n / abs(norm_z);\n"
"    radius_n = min(2.0f * radius, radius_n);\n"
"    return radius_n;\n"
"}\n"
"float confidence(float x, float y, float weighting) {\n"
"    const float maxRadDist = 400.0; //sqrt((width * 0.5)^2 + (height * 0.5)^2)\n"
"    const float twoSigmaSquared = 0.72; //2*(0.6^2) from paper\n"
"    vec2 pixelPosCentered = vec2(x, y) - cam.xy;\n"
"    float radialDist = sqrt(dot(pixelPosCentered, pixelPosCentered)) / maxRadDist;\n"
"    return exp((-(radialDist * radialDist) / twoSigmaSquared)) * weighting;\n"
"}\n"
"float encodeColor(vec3 c) {\n"
"    int rgb = int(round(c.x * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n"
"    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n"
"    return float(rgb);}\n"
"vec3 decodeColor(float c) {\n"
"    vec3 col;\n"
"    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n"
"    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n"
"    col.z = float(int(c) & 0xFF) / 255.0f;\n"
"    return col;}\n"
"//Central difference on floating point depth maps\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getVertex(vec2 texCoord, float x, float y, vec4 cam, sampler2D depth) {\n"
"    float z = float(textureLod(depth, texCoord, 0.0));\n"
"    return vec3((x - cam.x) * z * cam.z, (y - cam.y) * z * cam.w, z);\n"
"}\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getNormal(vec3 vPosition, vec2 texCoord, float x, float y, vec4 cam, sampler2D depth) {\n"
"    vec3 vPosition_xf = getVertex(vec2(texCoord.x + (1.0 / cols), texCoord.y), x + 1.0, y, cam, depth);\n"
"    vec3 vPosition_xb = getVertex(vec2(texCoord.x - (1.0 / cols), texCoord.y), x - 1.0, y, cam, depth);\n"
"    \n"
"    vec3 vPosition_yf = getVertex(vec2(texCoord.x, texCoord.y + (1.0 / rows)), x, y + 1.0, cam, depth);\n"
"    vec3 vPosition_yb = getVertex(vec2(texCoord.x, texCoord.y - (1.0 / rows)), x, y - 1.0, cam, depth);\n"
"    \n"
"    vec3 del_x = ((vPosition_xb + vPosition) / 2.0) - ((vPosition_xf + vPosition) / 2.0);\n"
"    vec3 del_y = ((vPosition_yb + vPosition) / 2.0) - ((vPosition_yf + vPosition) / 2.0);\n"
"    \n"
"    return normalize(cross(del_x, del_y));\n"
"}\n"
"//Forward difference on raw depth maps still in ushort mm\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getVertex(vec2 texcoord, int x, int y, vec4 cam, usampler2D depth) {\n"
"    float z = float(textureLod(depth, texcoord, 0.0)) / 1000.0f;\n"
"    return vec3((float(x) - cam.x) * z * cam.z, (float(y) - cam.y) * z * cam.w, z);\n"
"}\n"
"//Cam is //cx, cy, 1 / fx, 1 / fy\n"
"vec3 getNormal(vec3 vPosition, vec2 texcoord, int x, int y, vec4 cam, usampler2D depth) {\n"
"    vec3 vPosition_x = getVertex(vec2(texcoord.x + (1.0 / cols), texcoord.y), x + 1, y, cam, depth);\n"
"    vec3 vPosition_y = getVertex(vec2(texcoord.x, texcoord.y + (1.0 / rows)), x, y + 1, cam, depth);\n"
"    \n"
"    vec3 del_x = vPosition_x - vPosition;\n"
"    vec3 del_y = vPosition_y - vPosition;\n"
"    \n"
"    return normalize(cross(del_x, del_y));\n"
"}\n"
"void main() {\n"
"    //Should be guaranteed to be in bounds\n"
"    float x = texcoord.x * cols;\n"
"    float y = texcoord.y * rows;\n"
"    vPosition = vec4(getVertex(texcoord.xy, x, y, cam, gSampler), 1);\n"
"    vColor = textureLod(cSampler, texcoord.xy, 0.0);\n"
"    vec3 vNormLocal = getNormal(vPosition.xyz, texcoord.xy, x, y, cam, gSampler);\n"
"    vNormRad = vec4(vNormLocal, getRadius(vPosition.z, vNormLocal.z));\n"
"    if(vPosition.z <= 0.0 || vPosition.z > maxDepth) {\n"
"        zVal = 0.0;\n"
"    } else {\n"
"        zVal = vPosition.z;\n"
"    }\n"
"    vPosition.w = confidence(x, y, 1.0f);\n"
"    vColor.x = encodeColor(vColor.xyz);\n"
"    vColor.y = 0.0;\n"
"    //Timestamp\n"
"    vColor.w = float(time);\n"
"}\n";
static const std::tuple<std::string, std::string> vertex_feedbackvert_tuple = std::make_tuple("vertex_feedbackvert", vertex_feedbackvert_source);

static const char visualise_texturesfrag_source[] =
"#version 310 es\n"
"precision highp float;\n"
"precision highp int;\n"
"uniform sampler2D texVerts;\n"
"uniform float maxDepth;\n"
"in vec2 texcoord;\n"
"out vec4 FragColor;\n"
"void main() {\n"
"    vec4 vertex = texture(texVerts, texcoord);\n"
"    if(vertex.z > maxDepth || vertex.z <= 0.0) {\n"
"        discard;\n"
"    } else {\n"
"        FragColor = 1.0f - vec4(vertex.z / maxDepth);\n"
"    }\n"
"}\n";
static const std::tuple<std::string, std::string> visualise_texturesfrag_tuple = std::make_tuple("visualise_texturesfrag", visualise_texturesfrag_source);

#endif /* SHADERS_SHADERSSOURCE_H_ */
